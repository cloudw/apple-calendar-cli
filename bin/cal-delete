#!/usr/bin/osascript
-- Delete events by title from a calendar within a date range
-- Usage: ./cal-delete <calendar_name> <event_title> <start_date> <end_date>
-- Date format: YYYY-MM-DD or YYYY-MM-DD-HH-MM
-- Output: JSON object with deletion results

on run argv
    if length of argv < 4 then
        return "{\"error\": \"Usage: cal-delete <calendar_name> <event_title> <start_date> <end_date>\"}"
    end if
    
    try
        set calendarName to item 1 of argv
        set eventTitle to item 2 of argv
        set startDateStr to item 3 of argv
        set endDateStr to item 4 of argv
        
        set startDate to parse_date(startDateStr)
        set endDate to parse_date(endDateStr)
        
        set deleteCount to delete_events_by_title(calendarName, eventTitle, startDate, endDate)
        set jsonOutput to format_delete_result(eventTitle, deleteCount)
        
        return jsonOutput
    on error errMsg
        return "{\"error\": \"" & escapeJSONString(errMsg) & "\"}"
    end try
end run

on parse_date(dateStr)
    set dateComponents to my splitString(dateStr, "-")
    
    if length of dateComponents < 3 then
        error "Invalid date format. Use YYYY-MM-DD or YYYY-MM-DD-HH-MM"
    end if
    
    set yearNum to (item 1 of dateComponents) as integer
    set monthNum to (item 2 of dateComponents) as integer
    set dayNum to (item 3 of dateComponents) as integer
    
    set hourNum to 0
    set minuteNum to 0
    
    if length of dateComponents ≥ 4 then
        set hourNum to (item 4 of dateComponents) as integer
    end if
    
    if length of dateComponents ≥ 5 then
        set minuteNum to (item 5 of dateComponents) as integer
    end if
    
    return make_date(yearNum, monthNum, dayNum, hourNum, minuteNum)
end parse_date

on make_date(yearNum, monthNum, dayNum, hourNum, minuteNum)
    set newDate to current date
    set year of newDate to yearNum
    set month of newDate to monthNum
    set day of newDate to dayNum
    set hours of newDate to hourNum
    set minutes of newDate to minuteNum
    set seconds of newDate to 0
    return newDate
end make_date

on delete_events_by_title(calendarName, eventTitle, startDate, endDate)
    tell application "Calendar"
        tell calendar calendarName
            set eventsToDelete to every event whose summary is eventTitle and start date ≥ startDate and start date ≤ endDate
            set deleteCount to count of eventsToDelete
            repeat with eventToDelete in eventsToDelete
                delete eventToDelete
            end repeat
        end tell
        return deleteCount
    end tell
end delete_events_by_title

on format_delete_result(eventTitle, deleteCount)
    set eventTitleJSON to my escapeJSONString(eventTitle)
    
    set jsonOutput to "{"
    set jsonOutput to jsonOutput & "\"status\": \"deleted\","
    set jsonOutput to jsonOutput & "\"eventTitle\": \"" & eventTitleJSON & "\","
    set jsonOutput to jsonOutput & "\"eventsDeleted\": " & deleteCount
    set jsonOutput to jsonOutput & "}"
    
    return jsonOutput
end format_delete_result

on escapeJSONString(inputString)
    if inputString is missing value then return ""
    if inputString is "" then return ""
    
    set cleanedString to inputString as string
    
    -- Limit length to prevent JSON corruption
    if length of cleanedString > 500 then
        set cleanedString to (characters 1 thru 500 of cleanedString as string) & "..."
    end if
    
    -- Escape JSON special characters
    set escapedString to cleanedString
    
    -- Replace backslashes first (must be first)
    set escapedString to my replaceText(escapedString, "\\", "\\\\")
    
    -- Replace quotes
    set escapedString to my replaceText(escapedString, "\"", "\\\"")
    
    -- Replace newlines and returns
    set escapedString to my replaceText(escapedString, return, "\\n")
    set escapedString to my replaceText(escapedString, linefeed, "\\n")
    
    -- Replace tabs
    set escapedString to my replaceText(escapedString, tab, "\\t")
    
    -- Replace other problematic characters
    set escapedString to my replaceText(escapedString, "\r", "\\r")
    
    return escapedString
end escapeJSONString

on replaceText(inputString, searchString, replaceString)
    set AppleScript's text item delimiters to searchString
    set textItems to text items of inputString
    set AppleScript's text item delimiters to replaceString
    set outputString to textItems as string
    set AppleScript's text item delimiters to ""
    return outputString
end replaceText

on splitString(inputString, delimiter)
    set AppleScript's text item delimiters to delimiter
    set stringItems to text items of inputString
    set AppleScript's text item delimiters to ""
    return stringItems
end splitString